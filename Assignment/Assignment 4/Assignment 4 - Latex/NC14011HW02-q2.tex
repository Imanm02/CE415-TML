\section*{1.2}

فرض کنیم که زبان D تصمیم پذیر است و M یک ماشین تورینگ است که D را تصمیم می‌گیرد.

برای تشخیص پذیر بودن زبان C، ما می‌توانیم یک ماشین تورینگ N را به گونه‌ای بسازیم که به ازای ورودی x، تمامی رشته‌های y را می‌سازد و بررسی می‌کند که آیا 
$(x,y)$
در D هست یا نه. اگر چنین رشته‌ای وجود داشت، N x را قبول می‌کند. در غیر این صورت، N برای همیشه ادامه می‌یابد.

بنابراین، اگر D تصمیم پذیر باشد، C تشخیص پذیر است.

حال فرض کنیم که C تشخیص پذیر است و N ماشین تورینگی است که C را تشخیص می‌دهد.

برای تصمیم پذیر بودن D، ما می‌توانیم یک ماشین تورینگ M را بسازیم که ورودی‌های 
$(x,y)$
را می‌گیرد و بررسی می‌کند که آیا x در C قرار دارد. اگر بله،
$M (x,y)$
را قبول می‌کند. اگر نه،
$M (x,y)$
را رد می‌کند.

بنابراین، اگر C تشخیص پذیر باشد، D تصمیم پذیر است.

پس، زبان C تشخیص پذیر است اگر و تنها اگر زبان D تصمیم پذیر باشد.

\section*{2.2}

بیایید هر دو جهت این ادعا را بررسی کنیم.

اگر L تورینگ-تشخیص‌پذیر باشد، L* نیز تورینگ-تشخیص‌پذیر است.
در این جهت، اگر ماشین تورینگ M وجود داشته باشد که L را تشخیص می‌دهد، می‌توانیم یک ماشین تورینگ N بسازیم که L* را تشخیص می‌دهد. N به ازای هر ورودی w، همه‌ی تقسیم‌بندی‌های ممکن w را به رشته‌های w1, w2, ..., wn بررسی می‌کند و سپس هر کدام از این رشته‌ها را به M ورودی می‌دهد. اگر M همه‌ی این رشته‌ها را قبول کند، N w را قبول می‌کند. اگر نه، N برای تقسیم‌بندی بعدی ادامه می‌دهد. اگر هیچ یک از تقسیم‌بندی‌ها نتواند w را به رشته‌های قابل قبول تقسیم کند، N w را رد می‌کند. بنابراین، اگر L تورینگ-تشخیص‌پذیر باشد، L* نیز تورینگ-تشخیص‌پذیر است.

اگر L* تورینگ-تشخیص‌پذیر باشد، L نیز تورینگ-تشخیص‌پذیر است.
در این جهت، اگر ماشین تورینگ N وجود داشته باشد که L* را تشخیص می‌دهد، می‌توانیم یک ماشین تورینگ M بسازیم که L را تشخیص می‌دهد. M به ازای هر ورودی w، w را به N ورودی می‌دهد. اگر N w را قبول کند و w یک رشته از L است (یعنی فقط شامل یک عنصر از L* است)، M w را قبول می‌کند. در غیر این صورت، M w را رد می‌کند. بنابراین، اگر L* تورینگ-تشخیص‌پذیر باشد، L نیز تورینگ-تشخیص‌پذیر است.

پس، زبان L تورینگ-تشخیص‌پذیر است اگر و تنها اگر زبان L* تورینگ-تشخیص‌پذیر باشد.


\section*{3.2}

برای اینکه بتوانیم ثابت کنیم که یک زبان تصمیم‌پذیر است، باید بتوانیم یک الگوریتم یا ماشین تورینگ را ارائه دهیم که بتواند به ازای هر ورودی مشخص کند که آیا ورودی در زبان قرار دارد یا خیر.

در این مورد، زبان L شامل تمامی DFA هایی است که همه رشته‌های متعلق به زبان تعریف شده توسط آن DFA برابر با معکوس خود هستند. برای تشخیص اینکه آیا یک DFA برای یک ورودی خاص دارای این خاصیت است یا خیر، می‌توانیم الگوریتم زیر را اجرا کنیم:

برای هر وضعیت $q$ در $D$, و برای هر کاراکتر $a$ در الفبای $D$, اگر انتقال از $q$ با $a$ به $q'$ منتهی می‌شود، و $q'$ وضعیت پایانی است، آنگاه $q$ باید یک وضعیت شروع باشد و همچنین برعکس.

اگر همه وضعیت‌های $D$ این خاصیت را داشته باشند، آنگاه $D$ را قبول کن. در غیر این صورت، آن را رد کن.

این الگوریتم در زمان چندجمله‌ای اجرا می‌شود، زیرا تنها باید برای هر وضعیت و هر کاراکتر در الفبا، یک بررسی انجام دهد. بنابراین، این الگوریتم یک الگوریتم تصمیم‌گیری برای $L$ است، و $L$ تصمیم‌پذیر است.


\section*{4.2}

برای اثبات این موضوع، می‌توانیم یک الگوریتم ساده ارائه دهیم که به صورت گرافی PDA را بررسی می‌کند و تشخیص می‌دهد آیا حالت‌های غیرقابل دسترس وجود دارد یا خیر. الگوریتم به شرح زیر است:

ابتدا یک گراف G را با استفاده از PDA ایجاد می‌کنیم. در این گراف، هر حالت یک راس است و یک یال از راس i به راس j وجود دارد اگر و تنها اگر یک انتقال از حالت i به حالت j در PDA وجود داشته باشد.

از حالت اولیه PDA شروع کرده و یک جستجوی عمق اول (DFS) یا جستجوی سطح اول (BFS) را اجرا کنید تا تمام حالت‌های قابل دسترس را پیدا کنید.

در پایان، اگر هر حالتی در PDA را می‌توان با جستجویی که در مرحله 2 انجام داده‌ایم، دست یافت، PDA هیچ حالت غیرقابل دسترسی ندارد و بنابراین ورودی را رد می‌کنیم. اگر حالتی وجود داشته باشد که نمی‌توان به آن دست یافت، PDA حداقل یک حالت غیرقابل دسترس دارد و بنابراین ورودی را می‌پذیریم.

این الگوریتم در زمان چند جمله‌ای اجرا می‌شود (زیرا برای هر یال و راس در گراف G باید تنها یک عملیات انجام دهیم)، و بنابراین زبان L تصمیم‌پذیر است.